{"$message_type":"diagnostic","message":"borrowed data escapes outside of function","code":{"code":"E0521","explanation":"Borrowed data escapes outside of closure.\n\nErroneous code example:\n\n```compile_fail,E0521\nlet mut list: Vec<&str> = Vec::new();\n\nlet _add = |el: &str| {\n    list.push(el); // error: `el` escapes the closure body here\n};\n```\n\nA type annotation of a closure parameter implies a new lifetime declaration.\nConsider to drop it, the compiler is reliably able to infer them.\n\n```\nlet mut list: Vec<&str> = Vec::new();\n\nlet _add = |el| {\n    list.push(el);\n};\n```\n\nSee the [Closure type inference and annotation][closure-infere-annotation] and\n[Lifetime elision][lifetime-elision] sections of the Book for more details.\n\n[closure-infere-annotation]: https://doc.rust-lang.org/book/ch13-01-closures.html#closure-type-inference-and-annotation\n[lifetime-elision]: https://doc.rust-lang.org/reference/lifetime-elision.html\n"},"level":"error","spans":[{"file_name":"src/main.rs","byte_start":464,"byte_end":466,"line_start":14,"line_end":14,"column_start":31,"column_end":33,"is_primary":false,"text":[{"text":"fn create_thread<'a> (id:u32, rx: Receiver<&'static str>, ","highlight_start":31,"highlight_end":33}],"label":"`rx` declared here, outside of the function body","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/main.rs","byte_start":497,"byte_end":505,"line_start":15,"line_end":15,"column_start":5,"column_end":13,"is_primary":false,"text":[{"text":"    channels: &'a Vec<Sender<&'static str>>) -> JoinHandle<()> {","highlight_start":5,"highlight_end":13}],"label":"`channels` is a reference that is only valid in the function body","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/main.rs","byte_start":562,"byte_end":1038,"line_start":16,"line_end":29,"column_start":5,"column_end":7,"is_primary":true,"text":[{"text":"    thread::spawn(move || {","highlight_start":5,"highlight_end":28},{"text":"        loop {","highlight_start":1,"highlight_end":15},{"text":"            let mut buffer: VecDeque<&'static str> = VecDeque::new();","highlight_start":1,"highlight_end":70},{"text":"","highlight_start":1,"highlight_end":1},{"text":"            println!(\"Thread_{} alive\", id); ","highlight_start":1,"highlight_end":46},{"text":"            thread::sleep(Duration::from_secs(1));","highlight_start":1,"highlight_end":51},{"text":"            ","highlight_start":1,"highlight_end":13},{"text":"            if id == 1 {","highlight_start":1,"highlight_end":25},{"text":"            // let message = format!(\"{} sent a message to {}\", id, 2);","highlight_start":1,"highlight_end":72},{"text":"                send_message(2, \"sending message from id (1) to id (2)\", channels);","highlight_start":1,"highlight_end":84},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"            store_message(&rx, &mut buffer);","highlight_start":1,"highlight_end":45},{"text":"        }","highlight_start":1,"highlight_end":10},{"text":"    })","highlight_start":1,"highlight_end":7}],"label":"`channels` escapes the function body here","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/main.rs","byte_start":451,"byte_end":453,"line_start":14,"line_end":14,"column_start":18,"column_end":20,"is_primary":false,"text":[{"text":"fn create_thread<'a> (id:u32, rx: Receiver<&'static str>, ","highlight_start":18,"highlight_end":20}],"label":"lifetime `'a` defined here","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/main.rs","byte_start":562,"byte_end":1038,"line_start":16,"line_end":29,"column_start":5,"column_end":7,"is_primary":true,"text":[{"text":"    thread::spawn(move || {","highlight_start":5,"highlight_end":28},{"text":"        loop {","highlight_start":1,"highlight_end":15},{"text":"            let mut buffer: VecDeque<&'static str> = VecDeque::new();","highlight_start":1,"highlight_end":70},{"text":"","highlight_start":1,"highlight_end":1},{"text":"            println!(\"Thread_{} alive\", id); ","highlight_start":1,"highlight_end":46},{"text":"            thread::sleep(Duration::from_secs(1));","highlight_start":1,"highlight_end":51},{"text":"            ","highlight_start":1,"highlight_end":13},{"text":"            if id == 1 {","highlight_start":1,"highlight_end":25},{"text":"            // let message = format!(\"{} sent a message to {}\", id, 2);","highlight_start":1,"highlight_end":72},{"text":"                send_message(2, \"sending message from id (1) to id (2)\", channels);","highlight_start":1,"highlight_end":84},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"            store_message(&rx, &mut buffer);","highlight_start":1,"highlight_end":45},{"text":"        }","highlight_start":1,"highlight_end":10},{"text":"    })","highlight_start":1,"highlight_end":7}],"label":"argument requires that `'a` must outlive `'static`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0521]\u001b[0m\u001b[0m\u001b[1m: borrowed data escapes outside of function\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/main.rs:16:5\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m14\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m   \u001b[0m\u001b[0mfn create_thread<'a> (id:u32, rx: Receiver<&'static str>, \u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--\u001b[0m\u001b[0m           \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m`rx` declared here, outside of the function body\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12mlifetime `'a` defined here\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m15\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m   \u001b[0m\u001b[0m    channels: &'a Vec<Sender<&'static str>>) -> JoinHandle<()> {\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m       \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--------\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m`channels` is a reference that is only valid in the function body\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m16\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m/\u001b[0m\u001b[0m \u001b[0m\u001b[0m    thread::spawn(move || {\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m17\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m        loop {\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m18\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m            let mut buffer: VecDeque<&'static str> = VecDeque::new();\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m...\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m29\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    })\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m|\u001b[0m\u001b[0m      \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m|\u001b[0m\u001b[0m      \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m|\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m|______\u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m`channels` escapes the function body here\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m        \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9margument requires that `'a` must outlive `'static`\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"aborting due to 1 previous error","code":null,"level":"error","spans":[],"children":[],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror\u001b[0m\u001b[0m\u001b[1m: aborting due to 1 previous error\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"For more information about this error, try `rustc --explain E0521`.","code":null,"level":"failure-note","spans":[],"children":[],"rendered":"\u001b[0m\u001b[1mFor more information about this error, try `rustc --explain E0521`.\u001b[0m\n"}
